/**
 * PRCreator ‚Äî Creates Pull Requests for the AI healing branch
 * 
 * Creates PR from AI_Fix branch ‚Üí default branch
 * with structured body showing issues, fixes, and CI status.
 */

import { getInstallationOctokit } from '../github-app';

export class PRCreator {
    constructor(owner, repo, installationId) {
        this.owner = owner;
        this.repo = repo;
        this.installationId = installationId;
        this.octokit = null;
    }

    async _getOctokit() {
        if (!this.octokit) {
            this.octokit = await getInstallationOctokit(this.installationId);
        }
        return this.octokit;
    }

    /**
     * Create a PR from the AI branch to the default branch
     * 
     * @param {string} branchName - AI_Fix branch
     * @param {string} baseBranch - Default branch (main/master)
     * @param {Array} issues - List of detected issues
     * @param {Array} fixes - List of applied fixes
     * @param {number} retryCount - How many CI retries occurred
     * @param {string} ciStatus - Final CI status
     * @returns {Object} - { prUrl, prNumber }
     */
    async createPR(branchName, baseBranch, { issues, fixes, retryCount, ciStatus }) {
        const octokit = await this._getOctokit();

        // Check if PR already exists
        const existing = await this._findExistingPR(branchName, baseBranch);
        if (existing) {
            // Update existing PR body
            await this._updatePRBody(existing.number, { issues, fixes, retryCount, ciStatus });
            return { prUrl: existing.html_url, prNumber: existing.number };
        }

        const title = 'Autonomous AI Fix for Detected Issues';
        const body = this._buildPRBody(issues, fixes, retryCount, ciStatus);

        const { data: pr } = await octokit.rest.pulls.create({
            owner: this.owner,
            repo: this.repo,
            title,
            head: branchName,
            base: baseBranch,
            body,
        });

        console.log(`[PRCreator] Created PR #${pr.number}: ${pr.html_url}`);
        return { prUrl: pr.html_url, prNumber: pr.number };
    }

    /**
     * Update an existing PR body (for retry updates)
     */
    async _updatePRBody(prNumber, { issues, fixes, retryCount, ciStatus }) {
        const octokit = await this._getOctokit();
        const body = this._buildPRBody(issues, fixes, retryCount, ciStatus);

        await octokit.rest.pulls.update({
            owner: this.owner,
            repo: this.repo,
            pull_number: prNumber,
            body,
        });

        console.log(`[PRCreator] Updated PR #${prNumber}`);
    }

    /**
     * Find existing PR for the AI branch
     */
    async _findExistingPR(branchName, baseBranch) {
        const octokit = await this._getOctokit();

        try {
            const { data: prs } = await octokit.rest.pulls.list({
                owner: this.owner,
                repo: this.repo,
                head: `${this.owner}:${branchName}`,
                base: baseBranch,
                state: 'open',
            });
            return prs.length > 0 ? prs[0] : null;
        } catch (error) {
            return null;
        }
    }

    /**
     * Build structured PR body
     */
    _buildPRBody(issues, fixes, retryCount, ciStatus) {
        const statusEmoji = ciStatus === 'PASSED' ? '‚úÖ' : '‚ùå';
        const fixedCount = fixes.filter((f) => f.status === 'applied').length;

        let body = `## ü§ñ Autonomous AI Fix Report

> This PR was automatically generated by **CodeGuard Pro's AI Healing Agent**.

---

### üìä Summary

| Metric | Value |
|--------|-------|
| **Issues Detected** | ${issues.length} |
| **Fixes Applied** | ${fixedCount} |
| **CI Status** | ${statusEmoji} ${ciStatus} |
| **Retry Count** | ${retryCount} / 5 |

---

### üîç Issues Detected

| # | File | Line | Bug Type | Description |
|---|------|------|----------|-------------|
`;

        issues.forEach((issue, i) => {
            body += `| ${i + 1} | \`${issue.file}\` | ${issue.line} | \`${issue.bug_type}\` | ${issue.description.substring(0, 80)} |\n`;
        });

        body += `\n---\n\n### üîß Fixes Applied\n\n`;

        if (fixes.length > 0) {
            body += `| # | File | Bug Type | Commit Message | Status |\n`;
            body += `|---|------|----------|----------------|--------|\n`;

            fixes.forEach((fix, i) => {
                const statusBadge = fix.status === 'applied' ? '‚úÖ Applied' : '‚ùå Failed';
                body += `| ${i + 1} | \`${fix.file}\` | \`${fix.bug_type}\` | ${fix.commitMessage.substring(0, 60)} | ${statusBadge} |\n`;
            });
        } else {
            body += `_No fixes were applied._\n`;
        }

        body += `\n---\n\n### üîÑ CI/CD Status\n\n`;
        body += `- Final Status: **${statusEmoji} ${ciStatus}**\n`;
        body += `- Retry Attempts: **${retryCount}** / 5\n`;

        body += `\n---\n\n`;
        body += `> üõ°Ô∏è Generated by [CodeGuard Pro](https://github.com) Autonomous Healing Agent\n`;
        body += `> ‚è±Ô∏è ${new Date().toISOString()}\n`;

        return body;
    }
}
